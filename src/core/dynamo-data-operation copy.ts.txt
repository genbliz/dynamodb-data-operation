import { GenericDataError } from "../helpers/errors";
import { UtilService } from "../helpers/util-service";
import { DynamoDB } from "aws-sdk";
import { DocumentClient } from "aws-sdk/clients/dynamodb";
import { Marshaller } from "@aws/dynamodb-auto-marshaller";
import Joi from "@hapi/joi";
//
import { getJoiValidationErrors } from "./base-joi-helper";
import type {
  IDynamoScanParamOptions,
  IDynamoPagingParams,
  IDynamoQueryParamOptions,
} from "../types/base-declarations";
import { MyDynamoConnection } from "./dynamo-connection";
import DynamoHelperMixins from "./base-mixins";
import { ISecondaryIndexDef } from "../types/base-types";
import { LoggingService } from "../helpers/logging-service";

interface IBasicProps {
  id: string;
}

interface ITableConfig<T> {
  tableName: string;
  primaryHashKey: string;
  primaryRangeSortKey?: string;
  secondaryIndexOptions?: ISecondaryIndexDef<T>[];
  avoidDefaultTablePrefix?: boolean;
}

interface IDynamoOptions<T> {
  tableConfig: ITableConfig<T>;
  schemaDef: Joi.SchemaMap;
  canCreateTable: boolean;
  schemaGroup: "TENANT" | "CORE";
}

const getRandom = () =>
  [
    Math.round(Math.random() * 99999),
    Math.round(Math.random() * 88888),
    Math.round(Math.random() * 99),
  ].join("");

export abstract class AppDynamoDataOperation<T> extends DynamoHelperMixins {
  readonly #tableNamePrefix: string;
  //
  readonly #tableNamePrefixProd = "hospiman_mgt_";
  #schema: Joi.Schema;
  #marshaller: Marshaller;
  #tableFields: string[] = [];
  #tableConfig: ITableConfig<T>;
  #tableFullName: string;

  constructor({
    tableConfig,
    schemaDef,
    canCreateTable,
    schemaGroup,
  }: IDynamoOptions<T>) {
    super();
    this.#marshaller = new Marshaller({ onEmpty: "omit" });
    //
    this.#tableConfig = tableConfig;

    this.#tableNamePrefix = "table_prefix";

    const tableName = this.#tableConfig.tableName;
    const avoidDefaultTablePrefix = this.#tableConfig.avoidDefaultTablePrefix;

    this.#tableFullName =
      avoidDefaultTablePrefix === true
        ? tableName
        : `${this.#tableNamePrefix}${tableName}`;
    //
    this.#schema = BaseSchemaModelService.createCoreSchema(schemaDef);
    //
    if (canCreateTable) {
      this.allCreateTableIfNotExistsBase().catch((e) =>
        LoggingService.log({
          "@canCreateTable": e,
        })
      );
    }
  }

  private _dynamoDbClient(): DocumentClient {
    return MyDynamoConnection.dynamoDbClientInst();
  }

  private _dynamoDb(): DynamoDB {
    return MyDynamoConnection.dynamoDbInst();
  }

  protected async allGetTableInfoBase() {
    try {
      const params: DynamoDB.DescribeTableInput = {
        TableName: this.#tableFullName,
      };
      const result = await this._dynamoDb().describeTable(params).promise();
      if (result?.Table?.TableName === this.#tableFullName) {
        return result.Table;
      }
      return null;
    } catch (error) {
      LoggingService.log({ "@allGetTableInfoBase": "", error: error?.message });
      return null;
    }
  }

  protected async allCheckTableExistsBase() {
    const result = await this.allGetTableInfoBase();
    if (!result) {
      return false;
    }
    if (result?.GlobalSecondaryIndexes) {
      // console.log(JSON.stringify({ tableInfo: result }, null, 2));
    }
    return true;
  }

  protected async allCreateTableIfNotExistsBase() {
    const existingTableInfo = await this.allGetTableInfoBase();
    if (existingTableInfo) {
      if (this.#tableConfig.secondaryIndexOptions?.length) {
        await this._allUpdateGlobalSecondaryIndexBase({
          secondaryIndexOptions: this.#tableConfig.secondaryIndexOptions,
          existingTableInfo,
        });
      } else if (existingTableInfo.GlobalSecondaryIndexes?.length) {
        await this._allUpdateGlobalSecondaryIndexBase({
          secondaryIndexOptions: [],
          existingTableInfo,
        });
      }
      return null;
    }
    return await this.allCreateTableBase();
  }

  protected async allCreateTableBase() {
    const {
      //
      primaryHashKey,
      secondaryIndexOptions,
      primaryRangeSortKey,
    } = this.#tableConfig;

    const params: DynamoDB.CreateTableInput = {
      AttributeDefinitions: [
        {
          AttributeName: primaryHashKey,
          AttributeType: "S",
        },
      ],
      KeySchema: [
        {
          AttributeName: primaryHashKey,
          KeyType: "HASH",
        },
      ],
      BillingMode: "PAY_PER_REQUEST",
      TableName: this.#tableFullName,
    };

    if (!this.#tableConfig.avoidDefaultTablePrefix) {
      params.Tags = [
        {
          Key: "tablePrefix",
          Value: this.#tableNamePrefix,
        },
        {
          Key: `DDBTableGroupKey-${this.#tableNamePrefix}`,
          Value: this.#tableNamePrefix,
        },
      ];
    }

    if (primaryRangeSortKey) {
      params.AttributeDefinitions.push({
        AttributeName: primaryRangeSortKey,
        AttributeType: "S",
      });
      params.KeySchema.push({
        AttributeName: primaryRangeSortKey,
        KeyType: "RANGE",
      });
    }

    if (secondaryIndexOptions?.length) {
      const creationParams = this._getGlobalSecondaryIndexCreationParams(
        secondaryIndexOptions
      );
      if (creationParams.xAttributeDefinitions?.length) {
        const existAttrDefNames = params.AttributeDefinitions.map(
          (def) => def.AttributeName
        );
        creationParams.xAttributeDefinitions.forEach((def) => {
          const alreadyDefined = existAttrDefNames.includes(def.AttributeName);
          if (!alreadyDefined) {
            params.AttributeDefinitions.push(def);
          }
        });
      }
      params.GlobalSecondaryIndexes = [...creationParams.xGlobalSecondaryIndex];
    }

    LoggingService.log({
      "@allCreateTableBase, table: ": this.#tableFullName,
    });

    const result = await this._dynamoDb().createTable(params).promise();

    if (result?.TableDescription) {
      LoggingService.log(
        [
          `@allCreateTableBase,`,
          `Created table: '${result?.TableDescription.TableName}'`,
          new Date().toTimeString(),
        ].join(" ")
      );
      return result.TableDescription;
    }
    return null;
  }

  protected async allDeleteGlobalSecondaryIndexBase(indexName: string) {
    const params: DynamoDB.UpdateTableInput = {
      TableName: this.#tableFullName,
      GlobalSecondaryIndexUpdates: [
        {
          Delete: {
            IndexName: indexName,
          },
        },
      ],
    };
    const result = await this._dynamoDb().updateTable(params).promise();
    if (result?.TableDescription) {
      return result.TableDescription;
    }
    return null;
  }

  private _getGlobalSecondaryIndexCreationParams(
    secondaryIndexOptions: ISecondaryIndexDef<T>[]
  ) {
    //
    const params: DynamoDB.CreateTableInput = {
      KeySchema: [], //  make linter happy
      AttributeDefinitions: [],
      TableName: this.#tableFullName,
      GlobalSecondaryIndexes: [],
    };

    const attributeDefinitionsNameList: string[] = [];

    secondaryIndexOptions.forEach(
      ({ indexName, keyFieldName, sortFieldName, projectionFieldsInclude }) => {
        const _keyFieldName = keyFieldName as string;
        const _sortFieldName = sortFieldName as string;

        if (!attributeDefinitionsNameList.includes(_keyFieldName)) {
          attributeDefinitionsNameList.push(_keyFieldName);
          params?.AttributeDefinitions?.push({
            AttributeName: _keyFieldName,
            AttributeType: "S",
          });
        }

        if (!attributeDefinitionsNameList.includes(_sortFieldName)) {
          attributeDefinitionsNameList.push(_sortFieldName);
          params?.AttributeDefinitions?.push({
            AttributeName: _sortFieldName,
            AttributeType: "S",
          });
        }

        let projectionFields = (projectionFieldsInclude || []) as string[];
        let projectionType: AWS.DynamoDB.ProjectionType = "ALL";

        if (projectionFields?.length) {
          // remove frimary keys from include
          projectionFields = projectionFields.filter((field) => {
            return field !== _keyFieldName && field !== _sortFieldName;
          });
          if (projectionFields.length === 0) {
            // only keys was projceted
            projectionType = "KEYS_ONLY";
          } else {
            // only keys was projceted
            projectionType = "INCLUDE";
          }
        }

        params.GlobalSecondaryIndexes?.push({
          IndexName: indexName,
          Projection: {
            ProjectionType: projectionType,
            NonKeyAttributes:
              projectionType === "INCLUDE" ? projectionFields : undefined,
          },
          KeySchema: [
            {
              AttributeName: _keyFieldName,
              KeyType: "HASH",
            },
            {
              AttributeName: _sortFieldName,
              KeyType: "RANGE",
            },
          ],
        });
      }
    );
    return {
      xAttributeDefinitions: params.AttributeDefinitions || [],
      xGlobalSecondaryIndex: params.GlobalSecondaryIndexes || [],
    };
  }

  private async _allUpdateGlobalSecondaryIndexBase({
    secondaryIndexOptions,
    existingTableInfo,
  }: {
    secondaryIndexOptions: ISecondaryIndexDef<T>[];
    existingTableInfo: DynamoDB.TableDescription;
  }): Promise<DynamoDB.TableDescription[] | null> {
    try {
      const existingIndexNames: string[] = [];
      const staledIndexNames: string[] = [];
      const allIndexNames: string[] = [];
      const newSecondaryIndexOptions: ISecondaryIndexDef<T>[] = [];

      const updateResults: DynamoDB.TableDescription[] = [];

      if (existingTableInfo?.GlobalSecondaryIndexes?.length) {
        existingTableInfo?.GlobalSecondaryIndexes.forEach((indexInfo) => {
          if (indexInfo.IndexName) {
            existingIndexNames.push(indexInfo.IndexName);
          }
        });
      }

      secondaryIndexOptions?.forEach((newIndexInfo) => {
        allIndexNames.push(newIndexInfo.indexName);
        const indexExists = existingIndexNames.includes(newIndexInfo.indexName);
        if (!indexExists) {
          newSecondaryIndexOptions.push(newIndexInfo);
        }
      });

      existingIndexNames.forEach((indexName) => {
        const existsInList = allIndexNames.includes(indexName);
        if (!existsInList) {
          staledIndexNames.push(indexName);
        }
      });

      if (!(newSecondaryIndexOptions.length || staledIndexNames.length)) {
        return null;
      }

      let canUpdate = false;

      LoggingService.log({
        secondaryIndexOptions: secondaryIndexOptions.length,
        newSecondaryIndexOptions: newSecondaryIndexOptions.length,
        staledIndexNames: staledIndexNames.length,
        tableName: this.#tableFullName,
      });

      if (newSecondaryIndexOptions.length) {
        canUpdate = true;
        let indexCount = 0;
        for (const indexOption of newSecondaryIndexOptions) {
          const params: DynamoDB.UpdateTableInput = {
            TableName: this.#tableFullName,
            GlobalSecondaryIndexUpdates: [],
          };
          indexCount++;

          const creationParams = this._getGlobalSecondaryIndexCreationParams([
            indexOption,
          ]);

          const indexName = creationParams.xGlobalSecondaryIndex[0].IndexName;

          params.AttributeDefinitions = [
            ...creationParams.xAttributeDefinitions,
          ];

          creationParams.xGlobalSecondaryIndex.forEach((gsi) => {
            params.GlobalSecondaryIndexUpdates?.push({
              Create: {
                ...gsi,
              },
            });
          });

          const result = await this._dynamoDb().updateTable(params).promise();
          if (result?.TableDescription) {
            updateResults.push(result?.TableDescription);
          }

          LoggingService.log(
            [
              `Creating Index: '${indexName}'`,
              `on table '${this.#tableFullName}' started:`,
              new Date().toTimeString(),
            ].join(" ")
          );

          if (indexCount !== newSecondaryIndexOptions.length) {
            const label = `Created Index '${indexName}'`;
            console.time(label);
            await UtilService.waitUntilMunites(5);
            console.timeEnd(label);
          }
        }
      }

      if (staledIndexNames.length) {
        if (canUpdate) {
          await UtilService.waitUntilMunites(4);
        }
        canUpdate = true;
        let indexCount = 0;

        for (const indexName of staledIndexNames) {
          const params: DynamoDB.UpdateTableInput = {
            TableName: this.#tableFullName,
            GlobalSecondaryIndexUpdates: [],
          };

          indexCount++;

          params.GlobalSecondaryIndexUpdates?.push({
            Delete: {
              IndexName: indexName,
            },
          });

          const result = await this._dynamoDb().updateTable(params).promise();
          if (result?.TableDescription) {
            updateResults.push(result?.TableDescription);
          }

          LoggingService.log(
            [
              `Deleting Index: '${indexName}'`,
              `on table '${this.#tableFullName}' started:`,
              new Date().toTimeString(),
            ].join(" ")
          );

          if (indexCount !== staledIndexNames.length) {
            const label = `Deleted Index '${indexName}'`;
            console.time(label);
            await UtilService.waitUntilMunites(1);
            console.timeEnd(label);
          }
        }
      }

      if (!canUpdate) {
        return null;
      }

      if (updateResults.length) {
        console.log({
          "@allCreateGlobalSecondaryIndexBase": "",
          updateResults,
        });
        return updateResults;
      }
      return null;
    } catch (error) {
      LoggingService.log({
        "@allCreateGlobalSecondaryIndexBase": "",
        error: error?.message,
      });
      return null;
    }
  }

  protected allTableFullNameBase() {
    return Promise.resolve(this.#tableFullName);
  }

  protected abstract async allCreateTableIfNotExists(): Promise<DynamoDB.TableDescription | null>;

  protected async allGetListOfTablesNamesOnlineBase() {
    const params: DynamoDB.ListTablesInput = {
      Limit: 99,
    };
    const listOfTables = await this._dynamoDb().listTables(params).promise();
    return listOfTables?.TableNames;
  }

  protected allGetTableFieldNamesBase() {
    return [...this.#tableFields];
  }

  protected async allTableSettingUpdateTTLBase({
    attrName,
    isEnabled,
  }: {
    attrName: keyof T;
    isEnabled: boolean;
  }) {
    const params: DynamoDB.Types.UpdateTimeToLiveInput = {
      TableName: this.#tableFullName,
      TimeToLiveSpecification: {
        AttributeName: attrName as string,
        Enabled: isEnabled,
      },
    };
    const result = await this._dynamoDb().updateTimeToLive(params).promise();
    if (result?.TimeToLiveSpecification) {
      return result.TimeToLiveSpecification;
    }
    return null;
  }

  private async _allHelpValidateMarshallAndGetValue(data: any) {
    const { error, value } = this.#schema.validate(data, {
      stripUnknown: true,
    });

    if (error) {
      LoggingService.log({ "@JoiValidate": "", error, value });
      throw new GenericDataError(getJoiValidationErrors(error));
    }
    const marshalledData = this.#marshaller.marshallItem(value);
    return {
      validatedData: value,
      marshalled: marshalledData,
    };
  }

  private _allHelpCreateFullDataBase<Tn>({
    data,
    sessionUser,
  }: {
    data: Tn;
    sessionUser?: ISessionUser;
  }) {
    const dataMust = {
      createdAtDate: new Date().toISOString(),
    } as ICoreEntityBaseTenantModel;
    if (sessionUser && sessionUser.userId) {
      dataMust.creatorUserId = sessionUser.userId;
    }
    const fullData = { ...data, ...dataMust };
    if (!fullData.id) {
      fullData.id = generateDynamoTableKey();
    }
    return fullData;
  }

  protected async allCreateOneBase({
    data,
    sessionUser,
  }: {
    data: T;
    sessionUser?: ISessionUser;
  }) {
    const fullData = this._allHelpCreateFullDataBase({ data, sessionUser });
    const {
      validatedData,
      marshalled,
    } = await this._allHelpValidateMarshallAndGetValue(fullData);

    const params: DocumentClient.PutItemInput = {
      TableName: this.#tableFullName,
      Item: marshalled,
    };

    await this._dynamoDb().putItem(params).promise();
    const result: T = validatedData;
    return result;
  }

  protected async allQueryBySecondaryIndexBase<T>({
    keyQueryEquals: { keyFieldName, value },
    secondaryIndexName,
    orderDesc,
    sortKeyQueryOptions,
  }: {
    keyQueryEquals: { keyFieldName: keyof T; value: string | number };
    secondaryIndexName: string;
    orderDesc?: boolean;
    sortKeyQueryOptions?: IDynamoScanParamOptions<T>;
  }) {
    const result = await this.allQueryBySecondaryIndexPaginateBase<T>({
      keyQueryEquals: { keyFieldName, value },
      secondaryIndexName,
      orderDesc,
      sortKeyQueryOptions,
    });
    if (result?.mainResult) {
      return result.mainResult;
    }
    return [];
  }

  protected async allQueryBySecondaryIndexPaginateBase<T>({
    keyQueryEquals: { keyFieldName, value },
    secondaryIndexName,
    orderDesc,
    sortKeyQueryOptions,
  }: {
    keyQueryEquals: { keyFieldName: keyof T; value: string | number };
    secondaryIndexName: string;
    orderDesc?: boolean;
    sortKeyQueryOptions?: IDynamoScanParamOptions<T>;
  }) {
    if (!this.#tableConfig?.secondaryIndexOptions?.length) {
      throw new GenericDataError("Invalid secondary index definitions");
    }

    const secondaryIndex = this.#tableConfig.secondaryIndexOptions.find(
      ({ indexName }) => {
        return secondaryIndexName === indexName;
      }
    );

    if (!secondaryIndex) {
      throw new GenericDataError("Invalid secondary index name");
    }

    const hasField =
      (secondaryIndex.keyFieldName as string) === (keyFieldName as string);

    if (!hasField) {
      throw new GenericDataError("Invalid secondary index field definitions");
    }

    const paramOptions: IDynamoScanParamOptions<any> = {
      query: {
        ...(sortKeyQueryOptions?.query ?? {}),
        ...{ [keyFieldName]: value },
      },
      fields: sortKeyQueryOptions?.fields,
    };

    const {
      expressionAttributeValues,
      filterExpression,
      projectionExpressionAttr,
      expressionAttributeNames,
    } = this.__helperDynamoFilterOperation({
      queryDefs: paramOptions.query,
      projectionFields: paramOptions.fields,
    });

    const params: DocumentClient.QueryInput = {
      TableName: this.#tableFullName,
      IndexName: secondaryIndexName,
      KeyConditionExpression: filterExpression,
      //
      ExpressionAttributeValues: expressionAttributeValues,
      // FilterExpression: filterExpression,
      ExpressionAttributeNames: expressionAttributeNames,
    };

    if (orderDesc === true) {
      params.ScanIndexForward = false;
    }

    if (projectionExpressionAttr) {
      params.ProjectionExpression = projectionExpressionAttr;
    }

    const hashKeyName = secondaryIndex.keyFieldName as string;
    const sortKeyName = secondaryIndex.sortFieldName as string;

    const hashKeyAndSortKey: [string, string] = [hashKeyName, sortKeyName];

    const pagingParams = { ...paramOptions.pagingParams };

    const result = await this.__helperDynamoQueryProcessor<T>({
      params,
      orderDesc,
      hashKeyAndSortKey,
      ...pagingParams,
    });
    return result;
  }

  protected async allScanGetManyByConditionPaginateBase(
    paramOptions: IDynamoScanParamOptions<T>
  ) {
    const {
      expressionAttributeValues,
      filterExpression,
      projectionExpressionAttr,
      expressionAttributeNames,
    } = this.__helperDynamoFilterOperation({
      queryDefs: paramOptions.query,
      projectionFields: paramOptions.fields,
    });

    const params: DocumentClient.ScanInput = {
      TableName: this.#tableFullName,
      ExpressionAttributeValues: expressionAttributeValues,
      FilterExpression: filterExpression,
      ExpressionAttributeNames: expressionAttributeNames,
    };

    if (projectionExpressionAttr) {
      params.ProjectionExpression = projectionExpressionAttr;
    }

    const paginationObjects = paramOptions.pagingParams ?? {};
    const result = await this.__helperDynamoScanProcessor<T>({
      params,
      ...paginationObjects,
    });
    return result;
  }

  protected async allQueryExistsByConditionBase(
    paramOptions: IDynamoQueryParamOptions<T>
  ): Promise<boolean> {
    const result = await this.allQueryGetOneByConditionBase(paramOptions);
    if (result) {
      return true;
    }
    return false;
  }

  protected async allQueryGetOneByConditionBase<TExpectedVals = T>(
    paramOptions: IDynamoQueryParamOptions<T>
  ): Promise<TExpectedVals | null> {
    paramOptions.pagingParams = { pageSize: 1 };
    const result = await this.allQueryGetManyByConditionPaginateBase(
      paramOptions
    );
    if (result?.mainResult?.length) {
      const resultData: TExpectedVals = result.mainResult[0] as any;
      return resultData;
    }
    return null;
  }

  protected async allQueryGetManyByConditionBase(
    paramOptions: IDynamoQueryParamOptions<T>
  ) {
    paramOptions.pagingParams = undefined;
    const result = await this.allQueryGetManyByConditionPaginateBase(
      paramOptions
    );
    if (result?.mainResult?.length) {
      return result.mainResult;
    }
    return [];
  }

  protected async allQueryGetManyByConditionPaginateBase(
    paramOptions: IDynamoQueryParamOptions<T>
  ) {
    if (!paramOptions?.partitionSortKeyQuery?.partitionKeyEquals) {
      throw new GenericDataError("Invalid Hash key value");
    }
    if (!this.#tableConfig.primaryRangeSortKey) {
      throw new GenericDataError("Bad query sort configuration");
    }

    const hashKeyName = this.#tableConfig.primaryHashKey;
    const sortKeyName = this.#tableConfig.primaryRangeSortKey;

    let sortKeyQuery: any = {};

    const sortKeyQueryData = paramOptions.partitionSortKeyQuery.sortKeyQuery;
    if (sortKeyQueryData) {
      if (sortKeyQueryData[sortKeyName]) {
        sortKeyQuery = {
          [sortKeyName]: sortKeyQueryData[sortKeyName],
        };
      } else {
        throw new GenericDataError("Invalid Sort key value");
      }
    }

    const primaryHashKeyName = this.#tableConfig.primaryHashKey;
    const filterHashSortKey = this.__helperDynamoFilterOperation({
      queryDefs: {
        ...sortKeyQuery,
        ...{
          [primaryHashKeyName]:
            paramOptions.partitionSortKeyQuery.partitionKeyEquals,
        },
      },
      projectionFields: paramOptions?.fields ?? undefined,
    });
    //
    //
    let otherFilterExpression: string | undefined = undefined;
    let otherExpressionAttributeValues: any = undefined;
    let otherExpressionAttributeNames: any = undefined;
    if (paramOptions?.query) {
      const filterOtherAttributes = this.__helperDynamoFilterOperation({
        queryDefs: paramOptions.query,
        projectionFields: null,
      });

      otherExpressionAttributeValues =
        filterOtherAttributes.expressionAttributeValues;
      otherExpressionAttributeNames =
        filterOtherAttributes.expressionAttributeNames;

      if (
        filterOtherAttributes?.filterExpression &&
        filterOtherAttributes?.filterExpression.length > 1
      ) {
        otherFilterExpression = filterOtherAttributes.filterExpression;
      }
    }

    const params: DocumentClient.QueryInput = {
      TableName: this.#tableFullName,
      KeyConditionExpression: filterHashSortKey.filterExpression,
      ExpressionAttributeValues: {
        ...otherExpressionAttributeValues,
        ...filterHashSortKey.expressionAttributeValues,
      },
      FilterExpression: otherFilterExpression ?? undefined,
      ExpressionAttributeNames: {
        ...otherExpressionAttributeNames,
        ...filterHashSortKey.expressionAttributeNames,
      },
    };

    if (filterHashSortKey?.projectionExpressionAttr) {
      params.ProjectionExpression = filterHashSortKey.projectionExpressionAttr;
    }

    if (paramOptions?.pagingParams?.orderDesc === true) {
      params.ScanIndexForward = false;
    }

    const hashKeyAndSortKey: [string, string] = [hashKeyName, sortKeyName];

    const paginationObjects = { ...paramOptions.pagingParams };
    const result = await this.__helperDynamoQueryProcessor<T>({
      params,
      hashKeyAndSortKey,
      ...paginationObjects,
    });
    return result;
  }

  protected async allScanGetManyByConditionBase(
    paramOptions: IDynamoScanParamOptions<T>
  ) {
    const _paramOptions = { ...paramOptions };
    _paramOptions.pagingParams = undefined;
    const result = await this.allScanGetManyByConditionPaginateBase(
      _paramOptions
    );
    return result.mainResult;
  }

  protected async allGetByIdBase(dataId: string) {
    this.allHelpValidateRequiredString({ GetOnId: dataId });

    this._allErrorThrowNewErrorIfTableDoesNotHave_id_asOnlyHashPrimaryKey();

    const params: DocumentClient.GetItemInput = {
      TableName: this.#tableFullName,
      Key: {
        id: dataId,
      },
    };
    const _data = await this._dynamoDbClient().get(params).promise();
    const data: T = _data.Item as any;
    if (data) return data;
    return null;
  }

  protected async allQueryExistsByHashAndSortBase({
    hashKeyValue,
    sortKeyValue,
  }: {
    hashKeyValue: string;
    sortKeyValue: string;
  }) {
    const item = await this.allQueryGetOneByHashAndSortBase({
      hashKeyValue,
      sortKeyValue,
    });
    if (item) {
      return true;
    }
    return false;
  }

  protected async allQueryGetOneByHashAndSortBase({
    hashKeyValue,
    sortKeyValue,
  }: {
    hashKeyValue: string;
    sortKeyValue: string;
  }) {
    this._allErrorThrowNewErrorIfTableDoesNotHave_HashKey_and_sortKey_asPrimaryKey();

    this.allHelpValidateRequiredString({
      QueryGetOneHashKey: hashKeyValue,
      QueryGetOneSortKey: sortKeyValue,
    });

    const hashKeyName = this.#tableConfig.primaryHashKey;
    const sortKeyName = this.#tableConfig.primaryRangeSortKey || "";

    const params: DocumentClient.GetItemInput = {
      TableName: this.#tableFullName,
      Key: {
        [hashKeyName]: hashKeyValue,
        [sortKeyName]: sortKeyValue,
      },
    };
    const _data = await this._dynamoDbClient().get(params).promise();
    const data: T = _data.Item as any;
    if (data) return data;
    return null;
  }

  private _allErrorThrowNewErrorIfTableDoesNotHave_id_asOnlyHashPrimaryKey() {
    if (this.#tableConfig.primaryHashKey !== "id") {
      throw new GenericDataError(
        `Invalid search by primary key. Must have 'id' as primary.`
      );
    }
    if (this.#tableConfig.primaryRangeSortKey) {
      throw new GenericDataError(
        `Invalid search by primary key. Accepts only 'id' as primary.`
      );
    }
  }

  private _allErrorThrowNewErrorIfTableDoesNotHave_HashKey_and_sortKey_asPrimaryKey() {
    if (
      !(
        this.#tableConfig.primaryHashKey &&
        this.#tableConfig.primaryRangeSortKey
      )
    ) {
      throw new GenericDataError(
        "Invalid search by primary key. Accepts hash and sort only."
      );
    }
  }

  protected async allExistsByIdBase(dataId: string) {
    /* Confirmed Working */
    this._allErrorThrowNewErrorIfTableDoesNotHave_id_asOnlyHashPrimaryKey();

    this.allHelpValidateRequiredString({ Exist1DataId: dataId });

    const keys: (keyof IBasicProps)[] = ["id"];
    const data: IBasicProps = await this.allGetOneByIdProjectBase<IBasicProps>({
      dataId,
      projectionAttributes: keys,
    });
    if (data && data.id) {
      return true;
    }
    return false;
  }

  protected async allScanExistsByConditionBase(
    paramOptions: IDynamoScanParamOptions<T>
  ) {
    const data: IBasicProps | null = await this.allScanGetOneByConditionBase(
      paramOptions
    );
    if (data && data.id) {
      return true;
    }
    return false;
  }

  protected async allScanGetDataWithIdsBase(dataIds: string[]) {
    const paramOptions: IDynamoScanParamOptions<any> = {
      query: {
        id: { $in: dataIds },
      },
    };
    return this.allScanGetManyByConditionBase(paramOptions);
  }

  protected async allScanGetAllPagingBase(pagingParams?: IDynamoPagingParams) {
    const params: DocumentClient.ScanInput = {
      TableName: this.#tableFullName,
    };
    const _pagingParams = pagingParams ?? {};
    const result = await this.__helperDynamoScanProcessor<T>({
      params,
      ..._pagingParams,
    });
    return result;
  }

  protected async allScanGetAllBase() {
    const params: DocumentClient.ScanInput = {
      TableName: this.#tableFullName,
    };
    const result = await this.__helperDynamoScanProcessor<T>({ params });
    return result?.mainResult;
  }

  protected async allUpdateOneByIdBase({
    dataId,
    data,
    sessionUser,
  }: {
    dataId: string;
    data: T;
    sessionUser?: ISessionUser;
  }) {
    this._allErrorThrowNewErrorIfTableDoesNotHave_id_asOnlyHashPrimaryKey();

    this.allHelpValidateRequiredString({ Update1DataId: dataId });

    const dataInDb: IBasicProps & T = (await this.allGetByIdBase(
      dataId
    )) as any;

    if (!(dataInDb && dataInDb.id)) {
      throw new GenericDataError("Data does NOT exists");
    }

    const dataMust = {
      lastModifiedDate: new Date().toISOString(),
    } as ICoreEntityBaseModel;
    if (sessionUser?.userId) {
      dataMust.lastModifierUserId = sessionUser.userId;
    }
    const fullData = { ...dataInDb, ...data, ...dataMust };

    const {
      validatedData,
      marshalled,
    } = await this._allHelpValidateMarshallAndGetValue(fullData);

    const params: DocumentClient.PutItemInput = {
      TableName: this.#tableFullName,
      Item: marshalled,
    };

    await this._dynamoDb().putItem(params).promise();
    const result: T = validatedData;
    return result;
  }

  protected async allUpdateOneDirect({
    data,
    sessionUser,
  }: {
    data: T;
    sessionUser?: ISessionUser;
  }) {
    const dataMust = {
      lastModifiedDate: new Date().toISOString(),
    } as ICoreEntityBaseModel;
    if (sessionUser?.userId) {
      dataMust.lastModifierUserId = sessionUser.userId;
    }
    const fullData = { ...data, ...dataMust };
    //
    const {
      validatedData,
      marshalled,
    } = await this._allHelpValidateMarshallAndGetValue(fullData);

    const params: DocumentClient.PutItemInput = {
      TableName: this.#tableFullName,
      Item: marshalled,
    };

    await this._dynamoDb().putItem(params).promise();
    const result: T = validatedData;
    return result;
  }

  protected async allBatchGetManyByHashAndSortKey({
    hashSortKeys,
    fields,
  }: {
    hashSortKeys: {
      hashKeyValue: string;
      sortKeyValue: string;
    }[];
    fields?: (keyof T)[];
  }) {
    this._allErrorThrowNewErrorIfTableDoesNotHave_HashKey_and_sortKey_asPrimaryKey();
    //
    hashSortKeys.forEach(({ hashKeyValue, sortKeyValue }) => {
      this.allHelpValidateRequiredString({
        BatchGetHashKey: hashKeyValue,
        BatchGetSortKey: sortKeyValue,
      });
    });

    return new Promise<T[]>((resolve, reject) => {
      const hashKeyName = this.#tableConfig.primaryHashKey;
      const sortKeyName = this.#tableConfig.primaryRangeSortKey || "";

      const getArray: DynamoDB.Key[] = hashSortKeys.map(
        ({ hashKeyValue, sortKeyValue }) => {
          const params01 = {
            [hashKeyName]: { S: hashKeyValue },
            [sortKeyName]: { S: sortKeyValue },
          };
          return params01;
        }
      );

      const fullTableName = this.#tableFullName;

      let projectionExpression: string | undefined = undefined;
      let expressionAttributeNames:
        | DynamoDB.ExpressionAttributeNameMap
        | undefined = undefined;

      if (fields?.length) {
        const _fields: any[] = [...fields];
        expressionAttributeNames = {};
        _fields.forEach((fieldName) => {
          if (typeof fieldName === "string") {
            if (expressionAttributeNames) {
              const attrKeyHash = `#attrKey${getRandom()}k`.toLowerCase();
              expressionAttributeNames[attrKeyHash] = fieldName;
            }
          }
        });
        if (Object.keys(expressionAttributeNames)?.length) {
          projectionExpression = Object.keys(expressionAttributeNames).join(
            ","
          );
        } else {
          projectionExpression = undefined;
          expressionAttributeNames = undefined;
        }
      }

      const params: DynamoDB.BatchGetItemInput = {
        RequestItems: {
          [fullTableName]: {
            Keys: [...getArray],
            ConsistentRead: true,
            ProjectionExpression: projectionExpression,
            ExpressionAttributeNames: expressionAttributeNames,
          },
        },
      };

      let returnedItems: any[] = [];

      const batchGetUntilDone = (
        err: AWS.AWSError,
        data: DynamoDB.BatchGetItemOutput
      ) => {
        if (err) {
          if (returnedItems?.length) {
            resolve(returnedItems);
          } else {
            reject(err.stack);
          }
        } else {
          if (data?.Responses) {
            const itemListRaw = data.Responses[fullTableName];
            const itemList = itemListRaw.map((item) => {
              return this.#marshaller.unmarshallItem(item);
            });
            returnedItems = [...returnedItems, ...itemList];
          }
          if (data?.UnprocessedKeys) {
            const _params: DynamoDB.BatchGetItemInput = {
              RequestItems: data.UnprocessedKeys,
            };
            console.log({ dynamoBatchGetParams: _params });
            this._dynamoDb().batchGetItem(_params, batchGetUntilDone);
          } else {
            resolve(returnedItems);
          }
        }
      };
      this._dynamoDb().batchGetItem(params, batchGetUntilDone);
    });
  }

  protected async allDeleteManyDangerouselyByHashAndSortKey({
    hashSortKeys,
  }: {
    hashSortKeys: {
      hashKeyValue: string;
      sortKeyValue: string;
    }[];
  }): Promise<boolean> {
    this._allErrorThrowNewErrorIfTableDoesNotHave_HashKey_and_sortKey_asPrimaryKey();

    hashSortKeys.forEach(({ hashKeyValue, sortKeyValue }) => {
      this.allHelpValidateRequiredString({
        DelHashKey: hashKeyValue,
        DelSortKey: sortKeyValue,
      });
    });

    const hashKeyName = this.#tableConfig.primaryHashKey;
    const sortKeyName = this.#tableConfig.primaryRangeSortKey || "";

    const delArray = hashSortKeys.map(({ hashKeyValue, sortKeyValue }) => {
      const params01: DynamoDB.WriteRequest = {
        DeleteRequest: {
          Key: {
            [hashKeyName]: { S: hashKeyValue },
            [sortKeyName]: { S: sortKeyValue },
          },
        },
      };
      return params01;
    });

    const fullTableName = this.#tableFullName;

    const params: DynamoDB.BatchWriteItemInput = {
      RequestItems: {
        [fullTableName]: delArray,
      },
    };

    await this._dynamoDb().batchWriteItem(params).promise();
    return true;
  }

  protected async allDeleteManyDangerouselyByIds(
    dataIds: string[]
  ): Promise<boolean> {
    this._allErrorThrowNewErrorIfTableDoesNotHave_id_asOnlyHashPrimaryKey();

    const delArray = dataIds.map((dataId) => {
      const params01: DynamoDB.WriteRequest = {
        DeleteRequest: {
          Key: {
            id: { S: dataId },
          },
        },
      };
      return params01;
    });

    const fullTableName = this.#tableFullName;

    const params: DynamoDB.BatchWriteItemInput = {
      RequestItems: {
        [fullTableName]: delArray,
      },
    };

    await this._dynamoDb().batchWriteItem(params).promise();
    return true;
  }

  protected async allDeleteByHashAndSortKeyBase({
    hashKeyValue,
    sortKeyValue,
  }: {
    hashKeyValue: string;
    sortKeyValue: string;
  }): Promise<T> {
    this._allErrorThrowNewErrorIfTableDoesNotHave_HashKey_and_sortKey_asPrimaryKey();

    this.allHelpValidateRequiredString({
      Del1HashKey: hashKeyValue,
      Del1SortKey: sortKeyValue,
    });

    const hashKeyName = this.#tableConfig.primaryHashKey;
    const sortKeyName = this.#tableConfig.primaryRangeSortKey || "";

    const dataExist = (await this.allQueryGetOneByHashAndSortBase({
      hashKeyValue,
      sortKeyValue,
    })) as IBasicProps & T;
    if (!(dataExist && dataExist.id)) {
      throw new GenericDataError("Record does NOT exists");
    }

    const params: DocumentClient.DeleteItemInput = {
      TableName: this.#tableFullName,
      Key: {
        [hashKeyName]: hashKeyValue,
        [sortKeyName]: sortKeyValue,
      },
    };

    await this._dynamoDbClient().delete(params).promise();
    return dataExist;
  }

  protected async allDeleteByIdBase(dataId: string): Promise<T> {
    this._allErrorThrowNewErrorIfTableDoesNotHave_id_asOnlyHashPrimaryKey();

    this.allHelpValidateRequiredString({ Del1DataId: dataId });

    const params: DocumentClient.DeleteItemInput = {
      TableName: this.#tableFullName,
      Key: {
        id: dataId,
      },
    };

    const dataExist = (await this.allGetByIdBase(dataId)) as IBasicProps & T;
    if (!(dataExist && dataExist.id)) {
      throw new GenericDataError("Record does NOT exists");
    }

    await this._dynamoDbClient().delete(params).promise();
    return dataExist;
  }

  protected async allScanGetOneByConditionBase<TExpectedVals = T>(
    paramOptions: IDynamoScanParamOptions<T>
  ) {
    const {
      expressionAttributeValues,
      filterExpression,
      projectionExpressionAttr,
      expressionAttributeNames,
    } = this.__helperDynamoFilterOperation({
      queryDefs: paramOptions.query,
      projectionFields: paramOptions.fields,
    });

    const params: DocumentClient.ScanInput = {
      TableName: this.#tableFullName,
      ExpressionAttributeValues: expressionAttributeValues,
      FilterExpression: filterExpression,
      ExpressionAttributeNames: expressionAttributeNames,
    };

    if (projectionExpressionAttr) {
      params.ProjectionExpression = projectionExpressionAttr;
    }

    console.log({ allScanGetOneByConditionBase_paramOptions: paramOptions });
    console.log({ allScanGetOneByConditionBase_params: params });

    const result = await this.__helperDynamoScanProcessor<TExpectedVals>({
      params,
      pageSize: 1,
    });
    if (result?.mainResult?.length) {
      return result.mainResult[0];
    }
    return null;
  }

  protected async allGetOneByIdProjectBase<TExpectedVals = T>({
    dataId,
    projectionAttributes,
  }: {
    dataId: string;
    projectionAttributes: (keyof TExpectedVals)[];
  }) {
    this._allErrorThrowNewErrorIfTableDoesNotHave_id_asOnlyHashPrimaryKey();

    this.allHelpValidateRequiredString({ Get1DataId: dataId });

    const params: DocumentClient.GetItemInput = {
      TableName: this.#tableFullName,
      Key: {
        id: dataId,
      },
      ProjectionExpression: projectionAttributes.join(", ").trim(),
    };
    const _data = await this._dynamoDbClient().get(params).promise();
    const data: TExpectedVals = _data.Item as any;
    return data;
  }
}
